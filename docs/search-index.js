var searchIndex = JSON.parse('{\
"libsoxr":{"doc":"libsoxr-rsThis library is a thin wrapper for libsoxr which…","i":[[3,"Error","libsoxr","",null,null],[4,"ErrorType","","",null,null],[13,"InvalidString","","",0,null],[13,"CreateError","","",0,null],[13,"ChangeError","","",0,null],[13,"ProcessError","","",0,null],[0,"datatype","","Encapsulated data types for samples",null,null],[4,"Datatype","libsoxr::datatype","Datatypes supported for I/O to/from the resampler. Use the…",null,null],[13,"Float32I","","",1,null],[13,"Float64I","","",1,null],[13,"Int32I","","",1,null],[13,"Int16I","","",1,null],[13,"Float32S","","",1,null],[13,"Float64S","","",1,null],[13,"Int32S","","",1,null],[13,"Int16S","","",1,null],[11,"to_soxr_datatype","","helper function to convert from `Datatype` to…",1,[[],["soxr_datatype_t",6]]],[0,"soxr","libsoxr","Rust API for SOXR.",null,null],[3,"Soxr","libsoxr::soxr","This is the starting point for the Soxr algorithm.",null,null],[6,"SoxrFunction","","Signature of an input function that supplies SOXR with…",null,null],[11,"create","","Create a new resampler. When `io_spec`, `quality_spec` or…",2,[[["iospec",3],["qualityspec",3],["runtimespec",3],["option",4],["option",4],["option",4]],[["soxr",3],["result",6]]]],[11,"version","","Get version of libsoxr library",2,[[]]],[11,"set_error","","Set error of Soxr engine",2,[[["string",3]],["result",6]]],[11,"set_num_channels","","Change number of channels after creating Soxr object",2,[[],["result",6]]],[11,"error","","Query error status.",2,[[],[["option",4],["string",3]]]],[11,"num_clips","","Query int. clip counter (for R/W).",2,[[]]],[11,"delay","","Query current delay in output samples",2,[[]]],[11,"engine","","Query resampling engine name.",2,[[],["string",3]]],[11,"clear","","Ready for fresh signal, same config.",2,[[],["result",6]]],[11,"set_io_ratio","","For variable-rate resampling. See example # 5 of libsoxr…",2,[[],["result",6]]],[11,"process","","Resamples `Some(buf_in)` into `buf_out`. Type is dependent…",2,[[["option",4]],["result",6]]],[11,"set_input","","Sets the input function of type [SoxrFunction].",2,[[["soxrfunction",6],["option",4]],["result",6]]],[11,"output","","Resample and output a block of data using an app-supplied…",2,[[]]],[0,"spec","libsoxr","For specifying the runtime settings of the resampler For…",null,null],[3,"RuntimeSpec","libsoxr::spec","Wrapper for `soxr_runtime_spec_t`",null,null],[3,"IOSpec","","Wrapper for `soxr_io_spec_t`",null,null],[3,"QualityFlags","","",null,null],[3,"QualitySpec","","Wrapper for `soxr_quality_spec_t`",null,null],[4,"QualityRecipe","","",null,null],[13,"Quick","","",3,null],[13,"Low","","",3,null],[13,"Medium","","",3,null],[13,"High","","",3,null],[13,"VeryHigh","","",3,null],[11,"new","","creates a new `RuntimeSpec` for `num_threads` threads",4,[[],["runtimespec",3]]],[11,"soxr_spec","","returns inner soxr struct",4,[[],["soxr_runtime_spec_t",6]]],[11,"new","","creates a new `IOSpec` using `soxr_io_spec`",5,[[["datatype",4]],["iospec",3]]],[11,"soxr_spec","","returns inner soxr struct",5,[[],["soxr_io_spec_t",6]]],[18,"ROLLOFF_SMALL","","",6,null],[18,"ROLLOFF_MEDIUM","","",6,null],[18,"ROLLOFF_NONE","","",6,null],[18,"HI_PREC_CLOCK","","",6,null],[18,"VR","","",6,null],[11,"empty","","Returns an empty set of flags",6,[[],["qualityflags",3]]],[11,"all","","Returns the set containing all flags.",6,[[],["qualityflags",3]]],[11,"bits","","Returns the raw value of the flags currently stored.",6,[[],["c_ulong",6]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",6,[[["c_ulong",6]],[["option",4],["qualityflags",3]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",6,[[["c_ulong",6]],["qualityflags",3]]],[11,"from_bits_unchecked","","Convert from underlying bit representation, preserving all…",6,[[["c_ulong",6]],["qualityflags",3]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",6,[[]]],[11,"is_all","","Returns `true` if all flags are currently set.",6,[[]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",6,[[["qualityflags",3]]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",6,[[["qualityflags",3]]]],[11,"insert","","Inserts the specified flags in-place.",6,[[["qualityflags",3]]]],[11,"remove","","Removes the specified flags in-place.",6,[[["qualityflags",3]]]],[11,"toggle","","Toggles the specified flags in-place.",6,[[["qualityflags",3]]]],[11,"set","","Inserts or removes the specified flags depending on the…",6,[[["qualityflags",3]]]],[11,"to_recipe","","convert to SOXR constant",3,[[]]],[11,"new","","",7,[[["qualityflags",3],["qualityrecipe",4]],["qualityspec",3]]],[11,"soxr_spec","","returns inner soxr struct",7,[[],["soxr_quality_spec_t",6]]],[11,"new","libsoxr","",8,[[["cow",4],["errortype",4],["option",4]],["error",3]]],[11,"invalid_str","","",8,[[],["error",3]]],[6,"Result","","",null,null],[11,"from","","",8,[[]]],[11,"into","","",8,[[]]],[11,"to_string","","",8,[[],["string",3]]],[11,"borrow","","",8,[[]]],[11,"borrow_mut","","",8,[[]]],[11,"try_from","","",8,[[],["result",4]]],[11,"try_into","","",8,[[],["result",4]]],[11,"type_id","","",8,[[],["typeid",3]]],[11,"from","","",0,[[]]],[11,"into","","",0,[[]]],[11,"to_string","","",0,[[],["string",3]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"from","libsoxr::datatype","",1,[[]]],[11,"into","","",1,[[]]],[11,"to_owned","","",1,[[]]],[11,"clone_into","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from","libsoxr::soxr","",2,[[]]],[11,"into","","",2,[[]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"from","libsoxr::spec","",4,[[]]],[11,"into","","",4,[[]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"try_into","","",4,[[],["result",4]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"from","","",5,[[]]],[11,"into","","",5,[[]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"try_into","","",5,[[],["result",4]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"from","","",6,[[]]],[11,"into","","",6,[[]]],[11,"to_owned","","",6,[[]]],[11,"clone_into","","",6,[[]]],[11,"borrow","","",6,[[]]],[11,"borrow_mut","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"try_into","","",6,[[],["result",4]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"from","","",7,[[]]],[11,"into","","",7,[[]]],[11,"borrow","","",7,[[]]],[11,"borrow_mut","","",7,[[]]],[11,"try_from","","",7,[[],["result",4]]],[11,"try_into","","",7,[[],["result",4]]],[11,"type_id","","",7,[[],["typeid",3]]],[11,"from","","",3,[[]]],[11,"into","","",3,[[]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"try_into","","",3,[[],["result",4]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"drop","libsoxr::soxr","",2,[[]]],[11,"extend","libsoxr::spec","",6,[[["intoiterator",8]]]],[11,"clone","libsoxr::datatype","",1,[[],["datatype",4]]],[11,"clone","libsoxr::spec","",6,[[],["qualityflags",3]]],[11,"cmp","libsoxr::datatype","",1,[[["datatype",4]],["ordering",4]]],[11,"cmp","libsoxr::spec","",6,[[["qualityflags",3]],["ordering",4]]],[11,"eq","libsoxr::datatype","",1,[[["datatype",4]]]],[11,"eq","libsoxr::spec","",6,[[["qualityflags",3]]]],[11,"ne","","",6,[[["qualityflags",3]]]],[11,"partial_cmp","libsoxr::datatype","",1,[[["datatype",4]],[["ordering",4],["option",4]]]],[11,"partial_cmp","libsoxr::spec","",6,[[["qualityflags",3]],[["ordering",4],["option",4]]]],[11,"lt","","",6,[[["qualityflags",3]]]],[11,"le","","",6,[[["qualityflags",3]]]],[11,"gt","","",6,[[["qualityflags",3]]]],[11,"ge","","",6,[[["qualityflags",3]]]],[11,"fmt","libsoxr::datatype","",1,[[["formatter",3]],["result",6]]],[11,"fmt","libsoxr::soxr","",2,[[["formatter",3]],["result",6]]],[11,"fmt","libsoxr::spec","",6,[[["formatter",3]],["result",6]]],[11,"fmt","","",7,[[["formatter",3]],["result",6]]],[11,"fmt","libsoxr","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",8,[[["formatter",3]],["result",6]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",8,[[["formatter",3]],["result",6]]],[11,"sub","libsoxr::spec","Returns the set difference of the two sets of flags.",6,[[["qualityflags",3]],["qualityflags",3]]],[11,"sub_assign","","Disables all flags enabled in the set.",6,[[["qualityflags",3]]]],[11,"not","","Returns the complement of this set of flags.",6,[[],["qualityflags",3]]],[11,"bitand","","Returns the intersection between the two sets of flags.",6,[[["qualityflags",3]],["qualityflags",3]]],[11,"bitor","","Returns the union of the two sets of flags.",6,[[["qualityflags",3]],["qualityflags",3]]],[11,"bitxor","","Returns the left flags, but with all the right flags…",6,[[["qualityflags",3]],["qualityflags",3]]],[11,"bitand_assign","","Disables all flags disabled in the set.",6,[[["qualityflags",3]]]],[11,"bitor_assign","","Adds the set of flags.",6,[[["qualityflags",3]]]],[11,"bitxor_assign","","Toggles the set of flags.",6,[[["qualityflags",3]]]],[11,"hash","libsoxr::datatype","",1,[[]]],[11,"hash","libsoxr::spec","",6,[[]]],[11,"from_iter","","",6,[[["intoiterator",8]],["qualityflags",3]]],[11,"fmt","","",6,[[["formatter",3]],["result",6]]],[11,"fmt","","",6,[[["formatter",3]],["result",6]]],[11,"fmt","","",6,[[["formatter",3]],["result",6]]],[11,"fmt","","",6,[[["formatter",3]],["result",6]]],[11,"description","libsoxr","",8,[[]]]],"p":[[4,"ErrorType"],[4,"Datatype"],[3,"Soxr"],[4,"QualityRecipe"],[3,"RuntimeSpec"],[3,"IOSpec"],[3,"QualityFlags"],[3,"QualitySpec"],[3,"Error"]]}\
}');
addSearchOptions(searchIndex);initSearch(searchIndex);